# 进程的编号

## 1、查看进程

`ps` 查看当前终端的进程

`ps -ef` 查看系统全部的进程

`ps -ef|more` 查看系统全部的进程，结果分页显示

> ```
> UID	: 启动进程的操作系统用户
> PID : 进程编号
> PPID : 进程的父进程的编号
> C  	: CPU使用的资源占比
> STIME : 进程启动时间
> TTY : 进程所属的终端
> TIME : 使用掉的CPU时间
> CMD : 执行的是什么命令
> ```

`ps -ef|grep book` 查看系统的全部进程，然后从结果集中过滤出包含 “book” 单词的记录。



## 2、`getpid`库函数

`getpid`库函数的功能是获取本程序运行时进程的编号。

函数声明：

```C
pid_t getpid();
```

函数没有参数，返回值是进程的编号，`pid_t`就是`typedef int pid_t`

```c++
#include <unistd.h>

#include <iostream>

int main() {
  std::cout << getpid() << std::endl;
  return 0;
}
```



注意两个细节：

1) 进程的编号是系统动态分配的，相同的程序在不同的时间执行，进程的编号是不同的。
2) 进程的编号会循环使用，但是，在同一时间，进程的编号是唯一的，也就是说，不管任何时间，系统不可能存在两个编号相同的进程。

# 多进程

`fork` 在英文中是“分叉”的意思。一个进程在运行中，如果使用了`fork`函数，就产生了另一个进程，于是进程就“分叉”了。

函数声明：

```C
pid_t fork();
```

`fork` 函数用于产生一个新的进程，函数返回值`pid_t` 是一个整数，在父进程中，返回值是子进程编号，在子进程中，返回值是0。

```c++
void fork_test() {
  std::cout << "this process pid= " << getpid() << std::endl;
  int ipid = fork();
  std::cout << "ipid= " << ipid << std::endl;
  if (ipid == 0)
    std::cout << "father_pid= " << getpid() << std::endl;
  else
    std::cout << "son_pid= " << getpid() << std::endl;
}
```

`fork` 创建了一个新的进程，新进程（子进程）与原有的进程（父进程）一摸一样。子进程和父进程使用相同的代码段；子进程拷贝了父进程的堆栈段和数据段。子进程一旦开始运行，它复制了父进程的一切数据，然后各自运行，相互之间没有影响。

`fork`函数对返回值做了特别的处理，调用``fork``函数之后，在子程序中``fork``的返回值是0，在父进程中``fork``的返回值仍是原进程的编号, 可以通过fork的返回值来区分父进程和子进程，然后再执行不同的代码。

子进程拷贝了父进程的堆找段和数据段，也就是说，在父进程中定义的变量子进程中会复制一个副本，``fork``之后，子进程对变量的操作不会影响父进程，父进程对变量的操作也不会影响子进程。

# 多进程应用

```C
std::signal(SIGCHLD, SIG_IGN);   //  忽略子进程退出信号，避免产生僵尸进程
```

