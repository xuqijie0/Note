# 1、线程库的基本使用



- 进程就是运行中的程序
- 线程就是进程中的进程

线程的最大数量取决于cpu的核数

创建线程 `thread()`

主程序等待线程执行完毕 `join() `   join是阻塞的

分离线程`detach()`

## **创建线程**

要创建线程，我们需要一个可调用的函数或函数对象，作为线程的入口点。在C++11中，我们可以使用函数指针、函数对象或lambda表达式来实现。创建线程的基本语法如下：

`#include <thread>   std::thread t(function_name, args...);`

`function_name`是线程入口点的函数或可调用对象

`args...`是传递给函数的参数

创建线程后，我们可以使用`t.join()`等待线程完成，或者使用`t.detach()`分离线程，让它在后台运行。

例如，下面的代码创建了一个线程，输出一条消息：

```c++
#include <iostream>
#include <thread>
void print_message() {    
    std::cout << "Hello, world!" << std::endl;
}
int main() {
    std::thread t(print_message);
    t.join();
    return 0;
}
```

在这个例子中，我们定义了一个名为`print_message`的函数，它输出一条消息。然后，我们创建了一个名为`t`的线程，将`print_message`函数作为入口点。最后，我们使用`t.join()`等待线程完成。

## **传递参数**

我们可以使用多种方式向线程传递参数，例如使用函数参数、全局变量、引用等。如：

```c++
#include <iostream>
#include <thread>
void print_message(const std::string& message) {
    std::cout << message << std::endl;
}
void increment(int& x) {    
    ++x;
}
int main() {
    std::string message = "Hello, world!";
    std::thread t(print_message, message);
    t.join();
    int x = 0;
    std::thread t2(increment, std::ref(x));
    t2.join();
    std::cout << x << std::endl;
    return 0;
}
```

在第一个例子中，我们使用了一个字符串作为函数参数，传递给线程。在第二个例子中，我们使用了一个引用来传递一个整数变量。需要注意的是，当我们使用引用传递参数时，我们需要使用`std::ref`来包装引用，否则编译器会报错。

## **等待线程完成**

当我们创建一个线程后，我们可能需要等待它完成，以便获取线程的执行结果或执行清理操作。我们可以使用`t.join()`方法来等待线程完成。例如，下面的代码创建了两个线程，等待它们完成后输出一条消息：

```c++
#include <iostream>
#include <thread>
void print_message(const std::string& message) {
    std::cout << message << std::endl;
}
int main() {
    std::thread t1(print_message, "Thread 1");
    std::thread t2(print_message, "Thread 2");
    t1.join();
    t2.join();
    std::cout << "All threads joined" << std::endl;
    return 0;
}
```

在这个例子中，我们创建了两个线程`t1`和`t2`，它们都调用`print_message`函数输出一条消息。然后，我们使用`t1.join()`和`t2.join()`等待它们完成。最后，我们输出一条消息，表示所有线程都已经完成。

## **分离线程**

有时候我们可能不需要等待线程完成，而是希望它在后台运行。这时候我们可以使用`t.detach()`方法来分离线程。例如，下面的代码创建了一个线程，分离它后输出一条消息：

```
#include <iostream>
#include <thread>
void print_message(const std::string& message) {
	std::cout << message << std::endl;
}
int main() {
	std::thread t(print_message, "Thread 1");
    t.detach();
    std::cout << "Thread detached" << std::endl;
    return 0;
}
```

在这个例子中，我们创建了一个名为`t`的线程，调用`print_message`函数输出一条消息。然后，我们使用`t.detach()`方法分离线程，让它在后台运行。最后，我们输出一条消息，表示线程已经被分离。



需要注意的是，一旦线程被分离，就不能再使用`t.join()`方法等待它完成。而且，我们需要确保线程不会在主线程结束前退出，否则可能会导致未定义行为。

## **`joinable()`**



`joinable()`方法返回一个布尔值，如果线程可以被`join()`或``detach()``，则返回`true`，否则返回`false`。如果我们试图对一个不可加入的线程调用``join()``或``detach()``，则会抛出一个`std::system_error`异常。

下面是一个使用``joinable()``方法的例子：

```c++
#include <iostream>
#include <thread>
void foo() {
    std::cout << "Thread started" << std::endl;
}
int main() {
    std::thread t(foo);
    if (t.joinable()) {
        t.join();
    }
    std::cout << "Thread joined" << std::endl;
    return 0;
}
```

## **常见错误（后续内容中详解以下错误的解决方案）**

在使用C++11线程库时，有一些常见的错误需要注意。例如：

- 忘记等待线程完成或分离线程：如果我们创建了一个线程，但没有等待它完成或分离它，那么在主线程结束时，可能会导致未定义行为。
- 访问共享数据时没有同步：如果我们在多个线程中访问共享数据，但没有使用同步机制，那么可能会导致数据竞争、死锁等问题。
- 异常传递问题：如果在线程中发生了异常，但没有处理它，那么可能会导致程序崩溃。因此，我们应该在线程中使用try-catch块来捕获异常，并在适当的地方处理它。

## **总结**

C++11提供了一个强大的线程库，即`std::thread`。它可以在C++程序中创建和管理线程，提供了一种更加现代化的方式来处理多线程编程。在本文中，我们介绍了`std::thread`库的基本使用，包括如何创建、启动和管理线程，以及如何等待线程完成和分离线程。同时，我们也提到了一些常见的错误，需要注意避免。

# 2、线程函数中的数据未定义错误

## 传递临时变量的问题：

```c++
#include <iostream>
#include <thread>
void foo(int& x) {
    x += 1;
}
int main() {
    std::thread t(foo, 1); // 传递临时变量
    t.join();
    return 0;
}
```



在这个例子中，我们定义了一个名为`foo`的函数，它接受一个整数引用作为参数，并将该引用加1。然后，我们创建了一个名为`t`的线程，将`foo`函数以及一个临时变量`1`作为参数传递给它。这样会导致在线程函数执行时，临时变量`1`被销毁，从而导致未定义行为。



解决方案是将变量复制到一个持久的对象中，然后将该对象传递给线程。例如，我们可以将`1`复制到一个`int`类型的变量中，然后将该变量的引用传递给线程。

```c++
#include <iostream>
#include <thread>
void foo(int& x) {
    x += 1;
}
int main() {
    int x = 1; // 将变量复制到一个持久的对象中
    std::thread t(foo, std::ref(x)); // 将变量的引用传递给线程
    t.join();
    return 0;
}
```

## 传递指针或引用指向局部变量的问题：

```c++
#include <iostream>
#include <thread>

std::thread t;

void increment(int& x) {
	++x;
}

void test() {
	int a = 1;
	t = std::thread(increment, std::ref(a));//传递局部变量a
}

int main() {
    test();
    t.join();
    return 0;
}
```



在这个例子中，我们定义了一个名为`test`的函数，它创建了一个名为`t`的线程，将`increment`函数以及局部变量`a`的引用作为参数传递给它。这样会导致在线程函数执行时，局部变量`a`已经被销毁，从而导致未定义行为。



解决方案是将`a`定义为全局变量或者在线程函数执行期间，被传递对象的生命周期是有效的。

ooik传递指针或引用指向已释放的内存的问题：

```c++
#include <iostream>
#include <thread>
void foo(int& x) {
    std::cout << x << std::endl; // 访问已经被释放的内存
}
int main() {
    int* ptr = new int(1);
    std::thread t(foo, *ptr); // 传递已经释放的内存
    delete ptr;
    t.join();
    return 0;
}
```



在这个例子中，我们定义了一个名为`foo`的函数，它接受一个整数引用作为参数，并输出该引用的值。然后，我们创建了一个名为`t`的线程，将`foo`函数以及一个已经被释放的指针所指向的整数值作为参数传递给它。



解决方案是确保在线程函数执行期间，被传递的对象的生命周期是有效的。例如，在主线程中创建并初始化对象，然后将对象的引用传递给线程。

```c++
#include <iostream>
#include <thread>
void foo(int& x) {
    std::cout << x << std::endl;
}
int main() {
    int x = 1;
    std::thread t(foo, std::ref(x)); // 将变量的引用传递给线程
    t.join();
    return 0;
}
```



在这个例子中，我们创建了一个名为`x`的整数变量，并初始化为`1`。然后，我们创建了一个名为`t`的线程，将`foo`函数以及变量`x`的引用作为参数传递给它。这样可以确保在线程函数执行期间，变量`x`的生命周期是有效的。

##  类成员函数作为入口函数，类对象被提前释放

错误示例：

```c++
#include <iostream>
#include <thread>

class MyClass {
public:
    void func() {
        std::cout << "Thread " << std::this_thread::get_id() 
        << " started" << std::endl;
        // do some work
        std::cout << "Thread " << std::this_thread::get_id() 
        << " finished" << std::endl;
    }
};

int main() {
    MyClass obj;
    
    //	创建一个新线程并指定要执行的成员函数时，需要同时传递对象的指针（或引用）和成员函数的指针
    //	将成员函数作为参数传递给其他函数或对象时，需要使用 & 运算符来获取成员函数的地址
    std::thread t(&MyClass::func, &obj); 
    
    // obj 被提前销毁了，会导致未定义的行为
    
    return 0;
}
```



上面的代码中，在创建线程之后，obj 对象立即被销毁了，这会导致在线程执行时无法访问 obj 对象，可能会导致程序崩溃或者产生未定义的行为。



为了避免这个问题，可以使用 `std::shared_ptr` 来管理类对象的生命周期，确保在线程执行期间对象不会被销毁。具体来说，可以在创建线程之前，将类对象的指针封装在一个 `std::shared_ptr` 对象中，并将其作为参数传递给线程。这样，在线程执行期间，即使类对象的所有者释放了其所有权，`std::shared_ptr` 仍然会保持对象的生命周期，直到线程结束。



以下是使用 `std::shared_ptr` 修复上面错误的示例：

```c++
#include <iostream>
#include <thread>
#include <memory>

class MyClass {
public:
    void func() {
        std::cout << "Thread " << std::this_thread::get_id() 
        << " started" << std::endl;
        // do some work
        std::cout << "Thread " << std::this_thread::get_id() 
        << " finished" << std::endl;
    }
};

int main() {
    std::shared_ptr<MyClass> obj = std::make_shared<MyClass>();
    std::thread t(&MyClass::func, obj);
    t.join();
    return 0;
}
```



上面的代码中，使用 `std::make_shared` 创建了一个 `MyClass` 类对象，并将其封装在一个 `std::shared_ptr` 对象中。然后，将 `std::shared_ptr` 对象作为参数传递给线程。这样，在线程执行期间，即使 `obj` 对象的所有者释放了其所有权，`std::shared_ptr` 仍然会保持对象的生命周期，直到线程结束。

## 入口函数为类的私有成员函数

```c++
#include <iostream>
#include <thread>

class MyClass {
private:
	friend void myThreadFunc(MyClass* obj);
	void privateFunc(){
		std::cout << "Thread " 
		<< std::this_thread::get_id() << " privateFunc" << std::endl;
	}
};

void myThreadFunc(MyClass* obj) {
	obj->privateFunc();
}

int main() {
	MyClass obj;
	std::thread thread_1(myThreadFunc, &obj);
	thread_1.join();
	return 0;
}
```

上面的代码中，将 `myThreadFunc` 定义为 `MyClass` 类的友元函数，并在函数中调用 `privateFunc` 函数。在创建线程时，需要将类对象的指针作为参数传递给线程。



# 3、互斥量解决多线程数据共享问题

## **数据共享问题分析**

在多个线程中共享数据时，需要注意线程安全问题。如果多个线程同时访问同一个变量，并且其中至少有一个线程对该变量进行了写操作，那么就会出现数据竞争问题。数据竞争可能会导致程序崩溃、产生未定义的结果，或者得到错误的结果。

为了避免数据竞争问题，需要使用同步机制来确保多个线程之间对共享数据的访问是安全的。常见的同步机制包括互斥量、条件变量、原子操作等。

以下是一个简单的数据共享问题的示例代码：

```c++
#include <iostream>
#include <thread>
int shared_data = 0;
void func() {
    for (int i = 0; i < 100000; ++i) {
        shared_data++;
    }
}
int main() {
    std::thread t1(func);
    std::thread t2(func);
    t1.join();
    t2.join();
    std::cout << "shared_data = " << shared_data << std::endl;    
    return 0;
}
```

上面的代码中，定义了一个名为 `shared_data` 的全局变量，并在两个线程中对其进行累加操作。在 `main` 函数中，创建了两个线程，并分别调用了 `func` 函数。在 `func` 函数中，对 `shared_data` 变量进行了累加操作。

由于 `shared_data` 变量是全局变量，因此在两个线程中共享。对于这种共享的情况，需要使用互斥量等同步机制来确保多个线程之间对共享数据的访问是安全的。如果不使用同步机制，就会出现数据竞争问题，导致得到错误的结果。

## **互斥量概念**

互斥量（`mutex`）是一种用于实现多线程同步的机制，用于确保多个线程之间对共享资源的访问互斥。互斥量通常用于保护共享数据的访问，以避免多个线程同时访问同一个变量或者数据结构而导致的数据竞争问题。

互斥量提供了两个基本操作：`lock()` 和 `unlock()`。当一个线程调用 `lock()` 函数时，如果互斥量当前没有被其他线程占用，则该线程获得该互斥量的所有权，可以对共享资源进行访问。如果互斥量当前已经被其他线程占用，则调用 `lock()` 函数的线程会被阻塞，直到该互斥量被释放为止。



上面的代码中，使用互斥量 `mtx` 来确保多个线程对 `shared_data` 变量的访问是安全的。在 `func` 函数中，先调用 `mtx.lock()` 来获取互斥量的所有权，然后对 `shared_data` 变量进行累加操作，最后再调用 `mtx.unlock()` 来释放互斥量的所有权。这样就可以确保多个线程之间对 `shared_data` 变量的访问是安全的。

**案例代码**

以下是一个综合了创建多个线程和数据共享问题解决方案的示例代码：

```c++
#include <iostream>
#include <thread>
#include <mutex>
int shared_data = 0;
std::mutex mtx;
void func(int n) {
    for (int i = 0; i < 100000; ++i) {
        mtx.lock();
        shared_data++;        
        std::cout << "Thread " << n 
        << " increment shared_data to " << shared_data << std::endl;
        mtx.unlock();
    }
}
int main() {
    std::thread t1(func, 1);
    std::thread t2(func, 2);

    t1.join();
    t2.join();    
    std::cout << "Final shared_data = " << shared_data << std::endl;    
    return 0;
}
```



上面的代码中，定义了一个名为 `shared_data` 的全局变量，并使用互斥量 `mtx` 来确保多个线程对其进行访问时的线程安全。在两个线程中，分别调用了 `func` 函数，并传递了不同的参数。在 `func` 函数中，先获取互斥量的所有权，然后对 `shared_data` 变量进行累加操作，并输出变量的当前值。最后再释放互斥量的所有权。



# 4、互斥量死锁

假设有两个线程 `T1 `和 `T2`，它们需要对两个互斥量 `mtx1` 和 `mtx2` 进行访问，而且需要按照以下顺序获取互斥量的所有权：



\- `T1` 先获取 `mtx1` 的所有权，再获取 `mtx2` 的所有权。

\- `T2` 先获取 `mtx2` 的所有权，再获取 `mtx1` 的所有权。



如果两个线程同时执行，就会出现死锁问题。因为 `T1` 获取了 `mtx1` 的所有权，但是无法获取 `mtx2` 的所有权，而 `T2` 获取了 `mtx2` 的所有权，但是无法获取 `mtx1` 的所有权，两个线程互相等待对方释放互斥量，导致死锁。



```c++
#include <iostream>
#include <thread>
#include <mutex>

int a = 0;
std::mutex m1, m2;
void func_1() {
	for (int i = 0; i < 1000; ++i) {
		m1.lock();
		m2.lock();
		m2.unlock();
		m1.unlock();
	}
}

void func_2() {
	for (int i = 0; i < 1000; ++i) {
		m2.lock();
		m1.lock();
		m1.unlock();
		m2.unlock();
	}
}

int main() {
	std::thread t1(func_1);
	std::thread t2(func_2);

	t1.join();
	t2.join();

	std::cout << a << std::endl;

	return 0;
}
```





为了解决这个问题，可以让两个线程按照相同的顺序获取互斥量的所有权。例如，都先获取 `mtx1` 的所有权，再获取 `mtx2` 的所有权，或者都先获取 `mtx2` 的所有权，再获取 `mtx1` 的所有权。这样就可以避免死锁问题。

```c++
#include <iostream>
#include <thread>
#include <mutex>

int a = 0;
std::mutex m1, m2;
void func_1() {
	for (int i = 0; i < 1000; ++i) {
		m1.lock();
		m2.lock();
		m1.unlock();
		m2.unlock();
	}
}

void func_2() {
	for (int i = 0; i < 1000; ++i) {
		m1.lock();
		m2.lock();
		m1.unlock();
		m2.unlock();
	}
}

int main() {
	std::thread t1(func_1);
	std::thread t2(func_2);

	t1.join();
	t2.join();

	std::cout << a << std::endl;

	return 0;
}
```

# 5、lock_guard 与 std::unique_lock

## **std::lock_guard**

`std::lock_guard` 是 C++ 标准库中的一种互斥量封装类，用于保护共享数据，防止多个线程同时访问同一资源而导致的数据竞争问题。

`std::lock_guard` 的特点如下：

> - 当构造函数被调用时，该互斥量会被自动锁定。
> - 当析构函数被调用时，该互斥量会被自动解锁。
> - `std::lock_guard` 对象不能复制或移动，因此它只能在局部作用域中使用。



## **std::unique_lock**

`std::unique_lock` 是 C++ 标准库中提供的一个互斥量封装类，用于在多线程程序中对互斥量进行加锁和解锁操作。它的主要特点是可以对互斥量进行更加灵活的管理，包括延迟加锁、条件变量、超时等。

`std::unique_lock` 提供了以下几个成员函数：

> - **`lock()`**：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁。
> - **`try_lock()`**：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则函数立即返回 `false`，否则返回 `true`。
> - **`try_lock_for(const std::chrono::duration<Rep, Period>& rel_time)`**：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间。
> - **`try_lock_until(const std::chrono::time_point<Clock, Duration>& abs_time)`**：尝试对互斥量进行加锁操作，如果当前互斥量已经被其他线程持有，则当前线程会被阻塞，直到互斥量被成功加锁，或者超过了指定的时间点。
> - **`unlock()`**：对互斥量进行解锁操作。

除了上述成员函数外，`std::unique_lock` 还提供了以下几个构造函数：

> - `unique_lock() noexcept = default`：默认构造函数，创建一个未关联任何互斥量的 `std::unique_lock` 对象。
> - `explicit unique_lock(mutex_type& m)`：构造函数，使用给定的互斥量 `m` 进行初始化，并对该互斥量进行加锁操作。
> - `unique_lock(mutex_type& m, defer_lock_t) noexcept`：构造函数，使用给定的互斥量 `m` 进行初始化，但不对该互斥量进行加锁操作。
> - `unique_lock(mutex_type& m, try_to_lock_t) noexcept`：构造函数，使用给定的互斥量 `m` 进行初始化，并尝试对该互斥量进行加锁操作。如果加锁失败，则创建的 `std::unique_lock` 对象不与任何互斥量关联。
> - `unique_lock(mutex_type& m, adopt_lock_t) noexcept`：构造函数，使用给定的互斥量 `m` 进行初始化，并假设该互斥量已经被当前线程成功加锁。



# 6、std::call_once与其使用场景

单例设计模式是一种常见的设计模式，用于确保某个类只能创建一个实例。由于单例实例是全局唯一的，因此在多线程环境中使用单例模式时，需要考虑线程安全的问题。

下面是一个简单的单例模式的实现：

```c++
class Singleton {
public:
    static Singleton& getInstance() {
         static Singleton instance;
         return instance;
    }    
    void setData(int data) {
         m_data = data;
    }    
    int getData() const {
         return m_data;
    }
    
private:
    Singleton() {}
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;    
    int m_data = 0;
};
```

在这个单例类中，我们使用了一个静态成员函数 `getInstance()` 来获取单例实例，该函数使用了一个静态局部变量 `instance` 来存储单例实例。由于静态局部变量只会被初始化一次，因此该实现可以确保单例实例只会被创建一次。

但是，该实现并不是线程安全的。如果多个线程同时调用 `getInstance()` 函数，可能会导致多个对象被创建，从而违反了单例模式的要求。此外，如果多个线程同时调用 `setData()` 函数来修改单例对象的数据成员 `m_data`，可能会导致数据不一致或不正确的结果。

为了解决这些问题，我们可以使用 `std::call_once` 来实现一次性初始化，从而确保单例实例只会被创建一次。下面是一个使用 `std::call_once` 的单例实现：

```c++
class Singleton {
public:
    static Singleton& getInstance() {
            std::call_once(m_onceFlag, &Singleton::init);
            return *m_instance;
    }    
    void setData(int data) {
        m_data = data;
    }    
    int getData() const {        
    return m_data;
    }
private:
    Singleton() {}
    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;    
    static void init() {
        m_instance.reset(new Singleton);
    }    
    static std::unique_ptr<Singleton> m_instance;    
    static std::once_flag m_onceFlag;    
    int m_data = 0;
};
std::unique_ptr<Singleton> Singleton::m_instance;
std::once_flag Singleton::m_onceFlag;
```

在这个实现中，我们使用了一个静态成员变量 `m_instance` 来存储单例实例，使用了一个静态成员变量 `m_onceFlag` 来标记初始化是否已经完成。在 `getInstance()` 函数中，我们使用 `std::call_once` 来调用 `init()` 函数，确保单例实例只会被创建一次。在 `init()` 函数中，我们使用了 `std::unique_ptr` 来创建单例实例。

使用 `std::call_once` 可以确保单例实例只会被创建一次，从而避免了多个对象被创建的问题。此外，使用 `std::unique_ptr` 可以确保单例实例被正确地释放，避免了内存泄漏的问题。



`std::call_once` 是 C++11 标准库中的一个函数，用于确保某个函数只会被调用一次。其函数原型如下：

```c++
template<class Callable, class... Args>

void call_once(std::once_flag& flag, Callable&& func, Args&&... args);
```

其中，`flag` 是一个 `std::once_flag` 类型的对象，用于标记函数是否已经被调用；`func` 是需要被调用的函数或可调用对象；`args` 是函数或可调用对象的参数。



`std::call_once` 的作用是，确保在多个线程中同时调用 `call_once` 时，只有一个线程能够成功执行 `func` 函数，而其他线程则会等待该函数执行完成。



使用 `std::call_once` 的过程中，需要注意以下几点：

1. `flag` 参数必须是一个 `std::once_flag` 类型的对象，并且在多次调用 `call_once` 函数时需要使用同一个 `flag` 对象。
2. `func` 参数是需要被调用的函数或可调用对象。该函数只会被调用一次，因此应该确保该函数是幂等的。
3. `args` 参数是 `func` 函数或可调用对象的参数。如果 `func` 函数没有参数，则该参数可以省略。
4. `std::call_once` 函数会抛出 `std::system_error` 异常，如果在调用 `func` 函数时发生了异常，则该异常会被传递给调用者。

使用 `std::call_once` 可以在多线程环境中实现一次性初始化，避免了多个线程同时初始化的问题。只能在多线程中使用，不能写在main函数里。例如，在单例模式中，可以使用 `std::call_once` 来保证单例实例只会被创建一次。



# 7、condition_variable 与其使用场景

`std::condition_variable` 的步骤如下：

1. 创建一个 `std::condition_variable` 对象。

2. 创建一个互斥锁 `std::mutex` 对象，用来保护共享资源的访问。

3. 在需要等待条件变量的地方

   使用 `std::unique_lock<std::mutex>` 对象锁定互斥锁

   并调用 `std::condition_variable::wait()`、`std::condition_variable::wait_for()` 或 `std::condition_variable::wait_until()` 函数等待条件变量。

4. 在其他线程中需要通知等待的线程时，调用 `std::condition_variable::notify_one()` 或 `std::condition_variable::notify_all()` 函数通知等待的线程。

**生产者与消费者模型**

下面是一个简单的生产者-消费者模型的案例，其中使用了 `std::condition_variable` 来实现线程的等待和通知机制：

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <queue>
std::mutex g_mutex;
std::condition_variable g_cv;
std::queue<int> g_queue;

void Producer() {
    for (int i = 0; i < 10; i++) {
        {            
            std::unique_lock<std::mutex> lock(g_mutex);
            g_queue.push(i);            
            std::cout << "Producer: produced " << i << std::endl;
        }
        g_cv.notify_one();        
        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}
void Consumer() {    
    while (true) {        
        std::unique_lock<std::mutex> lock(g_mutex);
        g_cv.wait(lock, []() { return !g_queue.empty(); });        
        int value = g_queue.front();
        g_queue.pop();        
        std::cout << "Consumer: consumed " << value << std::endl;
    }
}
int main() {    
    std::thread producer_thread(Producer);    
    std::thread consumer_thread(Consumer);
    producer_thread.join();
    consumer_thread.join();    
    return 0;
}
```



使用 `std::condition_variable` 可以实现线程的等待和通知机制，从而在多线程环境中实现同步操作。在生产者-消费者模型中，使用 `std::condition_variable` 可以让消费者线程等待生产者线程生产数据后再进行消费，避免了数据丢失或者数据不一致的问题。



# 8、线程池

## **跨平台线程池实现**

它使用 C++11 标准库中的 `std::thread`、`std::mutex`、`std::condition_variable`、`std::function` 和 `std::queue` 等组件实现。



```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <functional>
#include <queue>

class ThreadPool {
public:
    ThreadPool(int numThreads) : stop(false) {
        for (int i = 0; i < numThreads; ++i) {
            threads.emplace_back([this] {
                while (true) {
                    std::unique_lock<std::mutex> lock(mutex);
                    condition.wait(lock, [this] { return stop || !tasks.empty(); });
                    if (stop && tasks.empty()) {
                        return;
                    }
                    std::function<void()> task(std::move(tasks.front()));
                    tasks.pop();
                    lock.unlock();
                    task();
                }
            });
        }
    }

    ~ThreadPool() {
        {
            std::unique_lock<std::mutex> lock(mutex);
            stop = true;
        }
        condition.notify_all();
        for (std::thread& thread : threads) {
            thread.join();
        }
    }

    template<typename F, typename... Args>
    void enqueue(F&& f, Args&&... args) {
        std::function<void()> task(std::bind(std::forward<F>(f), std::forward<Args>(args)...);
        {
            std::unique_lock<std::mutex> lock(mutex);
            tasks.emplace(std::move(task));
        }
        condition.notify_one();
    }

private:
    std::vector<std::thread> threads;
    std::queue<std::function<void()>> tasks;
    std::mutex mutex;
    std::condition_variable condition;
    bool stop;
};

int main() {
    ThreadPool pool(4);
    for (int i = 0; i < 8; ++i) {
        pool.enqueue([i] {
            std::cout << "Task " << i << " is running in thread " 
                << std::this_thread::get_id() << std::endl;
            std::this_thread::sleep_for(std::chrono::seconds(1));
            std::cout << "Task " << i << " is done" << std::endl;
        });
    }
    return 0;
}
```



在这个示例中，我们同样定义了一个 `ThreadPool`类，并且在构造函数中创建了指定数目的线程。在每个线程中，我们不断地从任务队列中获取任务并执行，直到线程池被停止。在 `enqueue()` 函数中，我们将任务封装成一个 `std::function` 对象，并将它添加到任务队列中。在 `ThreadPool` 的析构函数中，我们等待所有线程执行完成后再停止所有线程。

在主函数中，我们创建了一个 `ThreadPool` 对象，并向任务队列中添加了 8 个任务。每个任务会输出一些信息，并且在执行完后等待 1 秒钟。由于线程池中有 4 个线程，因此这 8 个任务会被分配到不同的线程中执行。在任务执行完成后，程序会退出。



# 9、C++并发三剑客 `future`, `promise`和`async`

##  `async`用法

`std::async` 是一个用于异步执行函数的模板函数，它返回一个 `std::future` 对象，该对象用于获取函数的返回值。

以下是一个使用 `std::async` 的示例：

```c++
#include <iostream>
#include <future>
#include <chrono>

// 定义一个异步任务
std::string fetchDataFromDB(std::string query) {
    // 模拟一个异步任务，比如从数据库中获取数据
    std::this_thread::sleep_for(std::chrono::seconds(5));
    return "Data: " + query;
}

int main() {
    // 使用 std::async 异步调用 fetchDataFromDB
    std::future<std::string> resultFromDB = std::async(std::launch::async, fetchDataFromDB, "Data");

    // 在主线程中做其他事情
    std::cout << "Doing something else..." << std::endl;

    // 从 future 对象中获取数据
    std::string dbData = resultFromDB.get();
    std::cout << dbData << std::endl;

    return 0;
}
```

在这个示例中，`std::async` 创建了一个新的线程（或从内部线程池中挑选一个线程）并自动与一个 `std::promise` 对象相关联。`std::promise` 对象被传递给 `fetchDataFromDB` 函数，函数的返回值被存储在 `std::future` 对象中。在主线程中，我们可以使用 `std::future::get` 方法从 `std::future` 对象中获取数据。注意，在使用 `std::async` 的情况下，我们必须使用 `std::launch::async` 标志来明确表明我们希望函数异步执行。

上面的例子输出

```
Doing something else...
Data: Data
```

## `async`的启动策略

`std::async`函数可以接受几个不同的启动策略，这些策略在`std::launch`枚举中定义。除了`std::launch::async`之外，还有以下启动策略：

1. `std::launch::deferred`：表示任务应该**延迟执行**（即不立即执行）。当指定 `std::launch::deferred` 时，与之关联的函数或可调用对象不会立即执行，直到在 `std::future` 对象上调用 `std::future::get()` 或 `std::future::wait()` 函数。任务的执行被推迟，直到显式请求为止。
2. `std::launch::async | std::launch::deferred`：这种策略是上面两个策略的组合。任务可以在一个单独的线程上异步执行，也可以延迟执行，具体取决于实现。

默认情况下，`std::async`使用`std::launch::async | std::launch::deferred`策略。这意味着任务可能异步执行，也可能延迟执行，具体取决于实现。需要注意的是，不同的编译器和操作系统可能会有不同的默认行为。

## `future`的`wait`和`get`

`std::future::get()` 和 `std::future::wait()` 是 C++ 中用于处理异步任务的两个方法，它们的功能和用法有一些重要的区别。

1. **std::future::get()**: 

   >`std::future::get()` 是一个阻塞调用，用于获取 `std::future` 对象表示的值或异常。如果异步任务还没有完成，`get()` 会阻塞当前线程，直到任务完成。如果任务已经完成，`get()` 会立即返回任务的结果。重要的是，`get()` 只能调用一次，因为它会移动或消耗掉 `std::future` 对象的状态。一旦 `get()` 被调用，`std::future` 对象就不能再被用来获取结果。

2. **std::future::wait()**:

   > `std::future::wait()` 也是一个阻塞调用，但它与 `get()` 的主要区别在于 `wait()` 不会返回任务的结果。它只是等待异步任务完成。如果任务已经完成，`wait()` 会立即返回。如果任务还没有完成，`wait()` 会阻塞当前线程，直到任务完成。与 `get()` 不同，`wait()` 可以被多次调用，它不会消耗掉 `std::future` 对象的状态。

总结一下，这两个方法的主要区别在于：

- `std::future::get()` 用于获取并返回任务的结果，而 `std::future::wait()` 只是等待任务完成。
- `get()` 只能调用一次，而 `wait()` 可以被多次调用。
- 如果任务还没有完成，`get()` 和 `wait()` 都会阻塞当前线程，但 `get()` 会一直阻塞直到任务完成并返回结果，而 `wait()` 只是在等待任务完成。

你可以使用`std::future`的`wait_for()`或``wait_until()``方法来检查异步操作是否已完成。这些方法返回一个表示操作状态的``std::future_status``值。

```c++
if(fut.wait_for(std::chrono::seconds(0)) == std::future_status::ready) {  
    // 操作已完成  
} else {  
    // 操作尚未完成  
}
```

## 将任务和future关联

`std::packaged_task`和`std::future`是C++11中引入的两个类，它们用于处理异步任务的结果。

`std::packaged_task`是一个可调用目标，它包装了一个任务，该任务可以在另一个线程上运行。它可以捕获任务的返回值或异常，并将其存储在`std::future`对象中，以便以后使用。

`std::future`代表一个异步操作的结果。它可以用于从异步任务中获取返回值或异常。

以下是使用`std::packaged_task`和`std::future`的基本步骤：

1. 创建一个`std::packaged_task`对象，该对象包装了要执行的任务。
2. 调用`std::packaged_task`对象的`get_future()`方法，该方法返回一个与任务关联的`std::future`对象。
3. 在另一个线程上调用`std::packaged_task`对象的`operator()`，以执行任务。
4. 在需要任务结果的地方，调用与任务关联的`std::future`对象的`get()`方法，以获取任务的返回值或异常。

以下是一个简单的示例代码：

```c++
int my_task() {
	std::this_thread::sleep_for(std::chrono::seconds(5));
	std::cout << "my task run 5 s" << std::endl;
	return 42;
}

void use_package() {
	// 创建一个包装了任务的 std::packaged_task 对象  
	std::packaged_task<int()> task(my_task);

	// 获取与任务关联的 std::future 对象  
	std::future<int> result = task.get_future();

	// 在另一个线程上执行任务  
	std::thread t(std::move(task));
	t.detach(); // 将线程与主线程分离，以便主线程可以等待任务完成  

	// 等待任务完成并获取结果  
	int value = result.get();
	std::cout << "The result is: " << value << std::endl;

}
```

在上面的示例中，我们创建了一个包装了任务的`std::packaged_task`对象，并获取了与任务关联的`std::future`对象。然后，我们在另一个线程上执行任务，并等待任务完成并获取结果。最后，我们输出结果。

我们可以使用 `std::function` 和 `std::package_task` 来包装带参数的函数。`std::package_task` 是一个模板类，它包装了一个可调用对象，并允许我们将其作为异步任务传递。

## `promise` 用法

C++11引入了`std::promise`和`std::future`两个类，用于实现异步编程。`std::promise`用于在某一线程中设置某个值或异常，而`std::future`则用于在另一线程中获取这个值或异常。

下面是`std::promise`的基本用法：

```c++
#include <iostream>
#include <thread>
#include <future>

void set_value(std::promise<int> prom) {
    // 设置 promise 的值
    prom.set_value(10);
}

int main() {
    // 创建一个 promise 对象
    std::promise<int> prom;
    // 获取与 promise 相关联的 future 对象
    std::future<int> fut = prom.get_future();
    // 在新线程中设置 promise 的值
    std::thread t(set_value, std::move(prom));
    // 在主线程中获取 future 的值
    std::cout << "Waiting for the thread to set the value...\n";
    std::cout << "Value set by the thread: " << fut.get() << '\n';
    t.join();
    return 0;
}
```

程序输出

```
Waiting for the thread to set the value...
promise set value successValue set by the thread:
10
```

在上面的代码中，我们首先创建了一个`std::promise<int>`对象，然后通过调用`get_future()`方法获取与之相关联的`std::future<int>`对象。然后，我们在新线程中通过调用`set_value()`方法设置`promise`的值，并在主线程中通过调用`fut.get()`方法获取这个值。注意，在调用`fut.get()`方法时，如果`promise`的值还没有被设置，则该方法会阻塞当前线程，直到值被设置为止。

除了`set_value()`方法外，`std::promise`还有一个`set_exception()`方法，用于设置异常。该方法接受一个`std::exception_ptr`参数，该参数可以通过调用`std::current_exception()`方法获取。下面是一个例子：

```c++
#include <iostream>
#include <thread>
#include <future>

void set_exception(std::promise<void> prom) {
    try {
        // 抛出一个异常
        throw std::runtime_error("An error occurred!");
    } catch(...) {
        // 设置 promise 的异常
        prom.set_exception(std::current_exception());
    }
}

int main() {
    // 创建一个 promise 对象
    std::promise<void> prom;
    // 获取与 promise 相关联的 future 对象
    std::future<void> fut = prom.get_future();
    // 在新线程中设置 promise 的异常
    std::thread t(set_exception, std::move(prom));
    // 在主线程中获取 future 的异常
    try {
        std::cout << "Waiting for the thread to set the exception...\n";
        fut.get();
    } catch(const std::exception& e) {
        std::cout << "Exception set by the thread: " << e.what() << '\n';
    }
    t.join();
    return 0;
}
```

上述代码输出

```
Waiting for the thread to set the exception...
Exception set by the thread: An error occurred!
```

当然我们使用promise时要注意一点，如果promise被释放了，而其他的线程还未使用与promise关联的future，当其使用这个future时会报错。如下是一段错误展示

```c++
void use_promise_destruct() {
	std::thread t;
	std::future<int> fut;
	{
		// 创建一个 promise 对象
		std::promise<int> prom;
		// 获取与 promise 相关联的 future 对象
		fut = prom.get_future();
		// 在新线程中设置 promise 的值
		 t = std::thread(set_value, std::move(prom));
	}
	// 在主线程中获取 future 的值
	std::cout << "Waiting for the thread to set the value...\n";
	std::cout << "Value set by the thread: " << fut.get() << '\n';
	t.join();
}
```

随着局部作用域`}`的结束，`prom`可能被释放也可能会被延迟释放，如果立即释放则`fut.get()`获取的值会报`error_value`的错误。

## 共享类型的future

当我们需要多个线程等待同一个执行结果时，需要使用``std::shared_future``

以下是一个适合使用`std::shared_future`的场景，多个线程等待同一个异步操作的结果：

假设你有一个异步任务，需要多个线程等待其完成，然后这些线程需要访问任务的结果。在这种情况下，你可以使用`std::shared_future`来共享异步任务的结果。

```c++
void myFunction(std::promise<int>&& promise) {
	// 模拟一些工作
	std::this_thread::sleep_for(std::chrono::seconds(1));
	promise.set_value(42); // 设置 promise 的值
}

void threadFunction(std::shared_future<int> future) {
	try {
		int result = future.get();
		std::cout << "Result: " << result << std::endl;
	}
	catch (const std::future_error& e) {
		std::cout << "Future error: " << e.what() << std::endl;
	}
}

void use_shared_future() {
	std::promise<int> promise;
	std::shared_future<int> future = promise.get_future();

	std::thread myThread1(myFunction, std::move(promise)); // 将 promise 移动到线程中

	// 使用 share() 方法获取新的 shared_future 对象  

	std::thread myThread2(threadFunction, future);

	std::thread myThread3(threadFunction, future);

	myThread1.join();
	myThread2.join();
	myThread3.join();
}
```

在这个示例中，我们创建了一个`std::promise<int>`对象`promise`和一个与之关联的`std::shared_future<int>`对象`future`。然后，我们将`promise`对象移动到另一个线程`myThread1`中，该线程将执行`myFunction`函数，并在完成后设置`promise`的值。我们还创建了两个线程`myThread2`和`myThread3`，它们将等待`future`对象的结果。如果`myThread1`成功地设置了`promise`的值，那么`future.get()`将返回该值。这些线程可以同时访问和等待`future`对象的结果，而不会相互干扰。

但是大家要注意，如果一个`future`被移动给两个`shared_future`是错误的。

```c++
void use_shared_future() {
	std::promise<int> promise;
	std::shared_future<int> future = promise.get_future();

	std::thread myThread1(myFunction, std::move(promise)); // 将 promise 移动到线程中

	std::thread myThread2(threadFunction, std::move(future));
	std::thread myThread3(threadFunction, std::move(future));

	myThread1.join();
	myThread2.join();
	myThread3.join();
}
```

这种用法是错误的，一个`future`通过隐式构造传递给`shared_future`之后，这个`shared_future`被移动传递给两个线程是不合理的，因为第一次移动后`shared_future`的生命周期被转移了，接下来`myThread3`构造时用的`std::move(future)`future已经失效了，会报错，一般都是`no state` 之类的错误。

## 异常处理

`std::future` 是C++的一个模板类，它用于表示一个可能还没有准备好的异步操作的结果。你可以通过调用 `std::future::get` 方法来获取这个结果。如果在获取结果时发生了异常，那么 `std::future::get` 会重新抛出这个异常。

以下是一个例子，演示了如何在 `std::future` 中获取异常：

```c++
#include <iostream>
#include <future>
#include <stdexcept>
#include <thread>

void may_throw()
{
    // 这里我们抛出一个异常。在实际的程序中，这可能在任何地方发生。
    throw std::runtime_error("Oops, something went wrong!");
}

int main()
{
    // 创建一个异步任务
    std::future<void> result(std::async(std::launch::async, may_throw));

    try
    {
        // 获取结果（如果在获取结果时发生了异常，那么会重新抛出这个异常）
        result.get();
    }
    catch (const std::exception &e)
    {
        // 捕获并打印异常
        std::cerr << "Caught exception: " << e.what() << std::endl;
    }

    return 0;
}
```

在这个例子中，我们创建了一个异步任务 `may_throw`，这个任务会抛出一个异常。然后，我们创建一个 `std::future` 对象 `result` 来表示这个任务的结果。在 `main` 函数中，我们调用 `result.get()` 来获取任务的结果。如果在获取结果时发生了异常，那么 `result.get()` 会重新抛出这个异常，然后我们在 `catch` 块中捕获并打印这个异常。

上面的例子输出

```
Caught exception: Oops, something went wrong!
```

